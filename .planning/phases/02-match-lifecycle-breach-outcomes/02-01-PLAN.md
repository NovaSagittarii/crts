---
phase: 02-match-lifecycle-breach-outcomes
plan: '01'
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/rts-engine/match-lifecycle.ts
  - packages/rts-engine/match-lifecycle.test.ts
  - packages/rts-engine/rts.ts
  - packages/rts-engine/rts.test.ts
  - packages/rts-engine/index.ts
autonomous: true
requirements:
  - MATCH-01
  - MATCH-02
must_haves:
  truths:
    - Lifecycle transition guards are deterministic and reusable from one engine authority.
    - Canonical breach resolution yields one explicit winner-first ranking even for same-tick eliminations.
    - Core structure instances expose HP/core identity/build radius aligned with README build-area semantics.
    - Final-results data includes ranked outcomes and required per-team stats for server/client consumption.
  artifacts:
    - path: packages/rts-engine/match-lifecycle.ts
      provides: Pure lifecycle transition and deterministic ranking utilities.
    - path: packages/rts-engine/rts.ts
      provides: Authoritative structure/core/breach state with canonical result snapshot builders.
    - path: packages/rts-engine/match-lifecycle.test.ts
      provides: Unit coverage for lifecycle guards and same-tick tie-break ordering.
    - path: packages/rts-engine/rts.test.ts
      provides: Unit coverage for core HP restore/destruction and buildRadius behavior.
  key_links:
    - from: packages/rts-engine/match-lifecycle.ts
      to: packages/rts-engine/rts.ts
      via: Lifecycle/outcome helpers consume engine snapshot metrics.
      pattern: determineMatchOutcome|rankTeamsForOutcome
    - from: packages/rts-engine/rts.ts
      to: StructureTemplate.buildArea
      via: Active structures project template buildArea onto instance buildRadius.
      pattern: buildRadius|buildArea
---

<objective>
Create deterministic engine-level lifecycle and breach-outcome primitives so server runtime can enforce one canonical match authority path.

Purpose: Lock MATCH-01/MATCH-02 semantics (including same-tick tie-break and core HP destruction) in reusable package code before wiring runtime handlers.
Output: New lifecycle/outcome helpers, expanded structure instance model, and unit tests covering locked decisions.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-match-lifecycle-breach-outcomes/02-CONTEXT.md
@.planning/phases/02-match-lifecycle-breach-outcomes/02-RESEARCH.md
@packages/rts-engine/rts.ts
@packages/rts-engine/rts.test.ts
@conway-rts/README.md
@conway-rts/DESIGN.md
</context>

<tasks>

<task type="auto">
  <name>task 1: codify RED unit specs for lifecycle transitions and canonical breach ranking</name>
  <files>packages/rts-engine/match-lifecycle.test.ts, packages/rts-engine/rts.test.ts</files>
  <action>Add failing unit tests for (a) legal lifecycle transitions `lobby -> countdown -> active -> finished`, `countdown -> lobby` cancel, and `finished -> countdown` restart guards, (b) deterministic same-tick elimination ordering using explicit comparator `coreHpBeforeResolution desc -> territoryCellCount desc -> appliedBuildCount desc -> teamId asc`, (c) winner-first ranked outcomes with per-team stats contract, and (d) structure-instance `buildRadius` semantics aligned to README `buildArea` (0 when inactive, template build-area value when active).</action>
  <verify>
    <automated>npx vitest run packages/rts-engine/match-lifecycle.test.ts packages/rts-engine/rts.test.ts</automated>
    <manual>Confirm new lifecycle/outcome assertions fail before implementation, then pass after tasks 2-3.</manual>
  </verify>
  <done>Lifecycle and breach contracts are explicitly test-defined, including the locked `buildRadius` structure decision.</done>
</task>

<task type="auto">
  <name>task 2: implement engine lifecycle and breach outcome authorities</name>
  <files>packages/rts-engine/match-lifecycle.ts, packages/rts-engine/rts.ts, packages/rts-engine/index.ts</files>
  <action>Implement pure lifecycle helpers that evaluate start/restart legality from authoritative precondition inputs (exactly one player per slot, both connected, no reconnect-hold pending) and apply deterministic transitions/cancel behavior. Extend `StructureInstance` with `hp`, `isCore`, and `buildRadius`, and implement periodic core restore checks that consume HP to reassert expected local shape; once HP reaches 0, mark the core destroyed and eligible for breach defeat. Add canonical breach outcome builders that emit winner-first ranked standings with multi-team-safe terminology (`winner`, `defeated`/`eliminated`) plus per-team stats: final core HP/state, territory/cell count, and queued/applied/rejected build counts. Track timeline events internally for future use but do not add timeline-display fields here.</action>
  <verify>
    <automated>npx vitest run packages/rts-engine/match-lifecycle.test.ts packages/rts-engine/rts.test.ts</automated>
  </verify>
  <done>Engine exports deterministic lifecycle/outcome primitives and authoritative structure-core model aligned with locked phase decisions.</done>
</task>

<task type="auto">
  <name>task 3: stabilize package exports and run rts-engine unit gate</name>
  <files>packages/rts-engine/index.ts, packages/rts-engine/match-lifecycle.ts</files>
  <action>Expose new lifecycle/outcome APIs through `#rts-engine` exports and ensure no server-only concerns leak into package code. Re-run full package unit coverage to verify existing queue/economy/defeat behavior remains deterministic after structure-model changes.</action>
  <verify>
    <automated>npx vitest run packages/rts-engine/*.test.ts</automated>
  </verify>
  <done>All rts-engine unit tests pass with new lifecycle/outcome APIs exported and backward-compatible behavior retained.</done>
</task>

</tasks>

<verification>
Run the task 3 command and confirm lifecycle/outcome unit tests plus existing RTS unit regressions pass together.
</verification>

<success_criteria>

- Engine has one documented deterministic tie-break metric and stable ranking output.
- Core-destruction breach logic depends on HP-based restore/destruction, not ad hoc room runtime checks.
- `StructureInstance.buildRadius` behavior matches README build-area semantics and is test-verified.
- Exported package APIs are ready for server lifecycle wiring without additional interpretation.
  </success_criteria>

<output>
After completion, create `.planning/phases/02-match-lifecycle-breach-outcomes/02-01-SUMMARY.md`
</output>
