---
phase: 03-deterministic-build-queue-validation
plan: '01'
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/rts-engine/rts.ts
  - packages/rts-engine/rts.test.ts
  - packages/rts-engine/socket-contract.ts
autonomous: true
requirements:
  - BUILD-02
  - BUILD-04
must_haves:
  truths:
    - Every accepted build event can be represented as one terminal result (`applied` or `rejected`) with explicit reason context.
    - Queue resolution order is deterministic for same-tick events (`executeTick`, then `eventId`).
    - Pending queued events are never silently discarded when a team is defeated or match flow terminates.
    - Validation reasons stay explicit for bounds and territory failures.
  artifacts:
    - path: packages/rts-engine/rts.ts
      provides: Deterministic build-resolution outputs and pending-event drain/rejection helpers.
    - path: packages/rts-engine/rts.test.ts
      provides: Unit coverage for terminal outcomes, deterministic ordering, and explicit rejection reasons.
    - path: packages/rts-engine/socket-contract.ts
      provides: Shared typed payload contract for terminal build outcomes and reason taxonomy.
  key_links:
    - from: packages/rts-engine/rts.ts
      to: packages/rts-engine/socket-contract.ts
      via: Engine terminal outcome fields align with transport payload fields and reason values.
      pattern: BuildOutcome|reason|executeTick|resolvedTick
    - from: packages/rts-engine/rts.ts
      to: packages/rts-engine/rts.test.ts
      via: Unit tests assert deterministic queue ordering and closure behavior.
      pattern: pendingBuildEvents\.sort|build-rejected|build-applied
---

<objective>
Add deterministic engine-level terminal outcome primitives so build queue events always resolve with explicit reasons and no silent drops.

Purpose: Deliver BUILD-02 and BUILD-04 in the package authority layer before runtime event wiring.
Output: Updated queue-resolution engine behavior, shared terminal-outcome types, and unit regression coverage.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-deterministic-build-queue-validation/03-RESEARCH.md
@packages/rts-engine/rts.ts
@packages/rts-engine/rts.test.ts
@packages/rts-engine/socket-contract.ts
</context>

<tasks>

<task type="auto">
  <name>task 1: add RED unit coverage for terminal build outcomes and deterministic tie-breaks</name>
  <files>packages/rts-engine/rts.test.ts</files>
  <action>Add failing unit tests that lock Phase-3 queue guarantees: (a) accepted queue events emit exactly one terminal result (`applied` or `rejected`) with `eventId`, `executeTick`, and `resolvedTick`, (b) same `executeTick` events resolve by `eventId` tie-break, (c) queued events pending at defeat/terminal cleanup are explicitly rejected (not dropped), and (d) out-of-bounds/outside-territory reasons remain explicit and stable. Keep tests focused on engine outputs; do not add server/socket assertions in this task.</action>
  <verify>
    <automated>npx vitest run packages/rts-engine/rts.test.ts</automated>
    <manual>Confirm new assertions fail before implementation and pass after task 2.</manual>
  </verify>
  <done>Unit suite captures deterministic terminal-outcome and reason-taxonomy behavior expected by BUILD-02/BUILD-04.</done>
</task>

<task type="auto">
  <name>task 2: implement engine terminal-outcome records and pending-event drain semantics</name>
  <files>packages/rts-engine/rts.ts</files>
  <action>Extend queue processing so each due build event produces one terminal outcome object with explicit fields (`eventId`, `teamId`, `outcome`, `reason?`, `executeTick`, `resolvedTick`). Add deterministic queue sorting with explicit comparator `executeTick asc` then `eventId asc`. Replace silent pending-event clears (for defeat/terminal transitions) with a deterministic drain helper that emits rejected outcomes with explicit reasons (for example `team-defeated` or `match-finished`). Keep queue validation centralized in existing `queueBuildEvent()` authority; do not introduce alternative mutation APIs in the package layer.</action>
  <verify>
    <automated>npx vitest run packages/rts-engine/rts.test.ts</automated>
  </verify>
  <done>Engine exposes deterministic terminal outcomes and explicit drain rejections with no silent queue loss paths.</done>
</task>

<task type="auto">
  <name>task 3: publish shared terminal outcome contract and run package regression gate</name>
  <files>packages/rts-engine/socket-contract.ts</files>
  <action>Add typed socket payload definitions for terminal outcomes and canonical rejection reason values (including bounds/territory failures) and keep `build:queued` acknowledgement contract unchanged. Use room-scoped outcome payloads to support deterministic observer/test visibility per research guidance. Do not add economy HUD or queue timeline UI fields (deferred to Phase 4).</action>
  <verify>
    <automated>npm run build:server && npx vitest run packages/rts-engine/rts.test.ts</automated>
  </verify>
  <done>Shared contract includes stable `build:outcome` payload typing and package tests still pass.</done>
</task>

</tasks>

<verification>
Run the task 3 command and confirm rts-engine queue tests pass with typed terminal-outcome contract available to runtime/test layers.
</verification>

<success_criteria>

- Accepted queue events are guaranteed to terminate as `applied` or `rejected(reason)`.
- Queue ordering for same execute tick is explicit and deterministic.
- No queue events are silently dropped on defeat/terminal cleanup paths.
- Bounds and territory rejections remain explicit and test-assertable.
  </success_criteria>

<output>
After completion, create `.planning/phases/03-deterministic-build-queue-validation/03-01-SUMMARY.md`
</output>
